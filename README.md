# Malware-Project

The binary_to_image_conversion folder contains code that can be used to represent APK files as images.

M1gray, M2gray, M3gray and M2color are techniques mentioned in C. Jaju, D. Agrawal, R. Poddar, S. Badjate, S. Anand, B. Mitra, and S. Dey, "Analyzing Image Based Strategies for Android Malware Detection and Classification: An Empirical Exploration," in 20th International Conference on Security and Cryptography (SECRYPT), Rome, Italy, July 2023, pp. 863-869.
These techniques were implemented to familiarize myself with the concept of converting binary files to images.

The files named Markov were used to generate Markov images which are used in the Lightweight CNN.
I convverted APK files from the CICAndMal2017 dataset to images.
The binary file is read as a sequence of bytes. A basic Markov image is the transfer 
probability matrix obtained by calculating p(Xk|X1), where k is a pre-defined value.
Each element pi,j in the matrix is the probability of a byte whose decimal value is j,
being k-1 pixels ahead of a byte whose decimal value is i.
A multidimensional Markov image is obtained by combining multiple basic Markov 
images depthwise (these basic Markov images differ in the value of k).



The Lightweight CNN folder contains code for for the Lightweight CNN mentioned in B. Yuan, J. Wang, P. Wu, and X. Qing, "IoT Malware Classification Based on Lightweight Convolutional Neural Networks," in IEEE Internet of Things Journal, vol. 9, no. 5, pp. 3770-3783, March 1, 2022, doi: 10.1109/JIOT.2021.3100063.
This LCNN classifies the images as benign, scareware, adware, SMSmalware or ransomware.
The networks in this folder differ in the number of channels in the input image.

This is LCNN is largely inspired by ShufflenetV2.
This architecture is extremely computation-efficient. It has fewer layers and trainable parameters than most other models that are used for this purpose.
It makes use of depthwise convolution followed by pointwise convolution instead of 
a single standard convolution. Doing this drastically reduces the model size and 
computations required.
From the architecture shown above, it is evident that we are making use of group
convolutions. This is done in order to reduce the complexity of pointwise 
convolutions. This can be a problem as information does not flow between channels 
of different groups. Using the channel shuffle operation is a solution to this problem.
It helps in the flow of information across feature channels
